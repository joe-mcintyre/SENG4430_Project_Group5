package com.tool.security.scan;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.tool.security.model.SecurityFinding;
import com.tool.security.model.SecuritySeverity;

import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;


//Adapter that reads an OWASP Dependency-Check JSON report from disk
public final class DependencyCheckJsonVulnerabilityProvider implements DependencyVulnerabilityProvider {

    private final ObjectMapper mapper = new ObjectMapper();

    //Loads and parses a Dependency-Check JSON report.
    @Override
    public SecurityScanData load(Path reportPath) throws Exception {
        if (reportPath == null || !Files.exists(reportPath)) {
            throw new IllegalArgumentException("Dependency-Check report not found: " + reportPath);
        }

        //Parse the JSON report into a tree
        JsonNode root = mapper.readTree(Files.newInputStream(reportPath));
        JsonNode deps = root.path("dependencies");

        int depCount = deps.isArray() ? deps.size() : 0;
        List<SecurityFinding> findings = new ArrayList<>();

        // If dependencies isn't an array, the report is malformed or empty.
        if (!deps.isArray()) {
            return new SecurityScanData(0, findings);
        }

        // Identify a readable label for the dependency.
        for (JsonNode dep : deps) {
            String depLabel = firstNonBlank(
                    textOrNull(dep, "fileName"),
                    textOrNull(dep, "displayFileName"),
                    textOrNull(dep, "filePath"),
                    "UNKNOWN_DEP"
            );

            JsonNode vulns = dep.path("vulnerabilities");
            if (!vulns.isArray()) continue;

            for (JsonNode v : vulns) {
                String cve = firstNonBlank(textOrNull(v, "name"), "UNKNOWN");
                String severityRaw = textOrNull(v, "severity");
                Double cvss = extractCvssBaseScore(v);

                SecuritySeverity sev = severityRaw != null
                        ? SecuritySeverity.fromString(severityRaw)
                        : SecuritySeverity.fromCvss(cvss);

                String desc = textOrNull(v, "description");

                // Dependency-Check does not reliably provide patch availability.
                Boolean patchAvailable = null;

                findings.add(new SecurityFinding(
                        cve,
                        cvss,
                        sev,
                        depLabel,
                        desc,
                        patchAvailable
                ));
            }
        }

        return new SecurityScanData(depCount, findings);
    }

    private Double extractCvssBaseScore(JsonNode vuln) {
        // Try common Dependency-Check formats.
        Double v3 = numberOrNull(vuln.path("cvssv3"), "baseScore");
        if (v3 != null) return v3;

        Double v2 = numberOrNull(vuln.path("cvssv2"), "score");
        if (v2 != null) return v2;

        Double direct = numberOrNull(vuln, "cvssScore");
        return direct;
    }

    //Extract a CVSS base score from a Dependency-Check vulnerability node.
    private String textOrNull(JsonNode node, String field) {
        JsonNode v = node.get(field);
        if (v == null || v.isNull()) return null;
        String s = v.asText();
        if (s == null) return null;
        s = s.trim();
        return s.isBlank() ? null : s;
    }

    //Safely reads a field as trimmed text, returning null (Field missing, jsnull or blank)
    private Double numberOrNull(JsonNode node, String field) {
        JsonNode v = node.get(field);
        if (v == null || v.isNull()) return null;
        if (v.isNumber()) return v.asDouble();
        String s = v.asText();
        if (s == null || s.isBlank()) return null;
        try {
            return Double.parseDouble(s.trim());
        } catch (Exception ignored) {
            return null;
        }
    }

    //Returns the first string that is not null and not blank.
    private String firstNonBlank(String... values) {
        for (String v : values) {
            if (v != null && !v.isBlank()) return v;
        }
        return null;
    }
}
